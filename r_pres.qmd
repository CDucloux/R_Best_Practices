---
title: "{{< iconify fa6-brands:r-project >}} Best Practices"
author: "*Corentin Ducloux*"
date: 08-12-2024
date-format: DD/MM/YYYY
title-slide-attributes:
    data-background-image: "assets/white_bg.jpg"
    data-background-size: contain
    data-background-opacity: "0.5"
format: 
    revealjs:
        background-transition: fade
        highlight-style: dracula
        incremental: true
        transition: fade
        slide-number: true
        navigation-mode: linear
        footer: "EDF | DISC | CNEPE"
        logo: assets/edf_logo.png
        css: assets/edf_styles.css
---

## Plan {.smaller}

1Ô∏è‚É£ Fonctions (P√ªret√©, Convention de nommage, Documentation)

2Ô∏è‚É£ Linter

3Ô∏è‚É£ Styler {{< iconify material-symbols:styler >}}

4Ô∏è‚É£ Les logs üí¨

5Ô∏è‚É£ Le pipe {{< iconify mdi:pipe >}} : `|>`

6Ô∏è‚É£ {{< iconify mdi:git >}} Git

7Ô∏è‚É£ Interop√©rabilit√©

## Les fonctions

::: {.callout-tip}

## Int√©r√™t d'une fonction

Une fonction en {{< iconify fa6-brands:r-project >}} est un bloc de code qui peut √™tre r√©utilis√© plusieurs fois pour effectuer une t√¢che sp√©cifique. Elles disposent de **param√®tres** et de **valeurs de retour**.
:::

> **Sc√©nario** : Calcul de l'aire de rectangles de taille variable.

Sur des cas aussi simples, on a tendance √† d√©j√† raisonner en fonction, mais ce n'est pas toujours vrai sur des cas plus complexes. En principe, il faut raisonner de mani√®re **DRY**^[Don't Repeat Yourself].

## Calcul, sans fonction

```{r}
#| echo: true

longueur_1 <- 2
largeur_1 <- 4
aire_1 <- longueur_1 * largeur_1

longueur_2 <- 2
largeur_2 <- 8
aire_2 <- longueur_2 * largeur_2

print(aire_1)
print(aire_2)
```

$\Rightarrow$ Naivement, on r√©-√©crit deux fois les m√™mes choses.

## Avec fonction

```{r}
#| echo: true

calcul_aire <- function(longueur, largeur) {
    aire <- longueur * largeur
    return(aire)
}

print(calcul_aire(2, 4))
print(calcul_aire(2, 8))
```

<hr>

**CONCLUSION** : Utiliser des fonctions n'est <u>JAMAIS</u> une punition, il y a un v√©ritable int√©r√™t !

## Une fonction horrible {.smaller}

```{r}
#| echo: true

U <- c(6, 9, 10)

zA1 <- function(v, c) {
    return(U[v] * c)
}

zA1(1, 8)
```

‚ùå Quels sont les probl√®mes de la fonction `zA1` ?

1. La fonction n'est pas pure - l'objet **U** est d√©fini plus haut mais n'est pas inclus en tant qu'argument.
2. Nom de la fonction pas clair -- √† quoi correspond `zA1` ?
3. Non-Respect des conventions de nommage (`snake_case` ou `TitleCase`).
4. Arguments vraiments pas clairs *(v,c)*.
5. Difficult√© d'interpr√©tation de la valeur de retour de la fonction `zA1`...
6. La fonction n'est pas document√©e.

## Puret√© d'une fonction

::: {.callout-tip}

## Puret√© d'une fonction

Une fonction pure poss√®de les propri√©t√©s suivantes :

- Sa valeur de retour est la m√™me **quand on utilise les m√™mes arguments** (pas de variation avec des variables statiques locales, ou des variables globales).

- Pas d'effets de bord.

:::

On a vu que `zA1` viole la premi√®re propri√©t√©, puisqu'elle utilise **U**, une variable globale, non d√©finie dans le corps de la fonction.

## Apart√© sur l'effet de bord {.smaller}

```{r}
#| echo: true
#| code-fold: true
type_age <- function(age) {
    if (age <= 0) {
        type <- "Un √¢ge ne peut pas √™tre n√©gatif ou √©gal √† 0"
    } else if (age < 18) {
        type <- "Mineur"
    } else if (age < 99) {
        type <- "Majeur"
    } else {
        type <- "Y'a un petit souci l√†..."
    }

    return(type)
}
```

```{r}
#| echo: true
age <- 19

type_age(age) |> print()

modifie_age <- function() {
    age <<- 2000 # Op√©rateur <<- √† bannir !
    return(age)
}

modifie_age() |> print()
age |> print()
type_age(age) |> print()
```

‚ùì On vient d'assigner une nouvelle valeur √† `age`, alors m√™me que `age` etait un argument d'entr√©e d'une autre fonction.

## Convention de nommage

![](assets/cases.png)

## Documentation Explicite

::: {.callout-tip}

## Roxygen

`{roxygen2}` est un package qui permet d'√©crire la documentation des fonctions dans des fichiers `.R` √† l'aide d'un squelette de commentaires situ√© au-dessus de la fonction.
:::

`@title` $\Rightarrow$ Titre de la fonction

`@description` $\Rightarrow$ Description de la fonction

`@param` $\Rightarrow$ Param√®tres de la fonction

`@returns` $\Rightarrow$ Valeurs de retour de la fonction

`@examples` $\Rightarrow$ Exemples d'utilisation

:::{.notes}
M√™me si roxygen est principalement utilis√© pour cr√©ation de packages, √ßa a du sens de documenter m√™me des fonctions qui ne sont pas contenues dans des packages.

On est pas dans un package R, donc pas besoin d'importer des d√©pendances sp√©cifiques ou d'exporter la fonction.
:::

## Documentation Implicite

::: {.callout-warning}

Il n'y a pas forc√©ment besoin de documentation avec `{roxygen2}` dans des petites fonctions dont le traitement est simple, √† partir du moment o√π il y a une **documentation implicite**.

:::

La documentation implicite revient √† d√©finir des noms de fonction et d'arguments coh√©rents *(si possible, en anglais)*.

## Am√©liorons la fonction {.smaller}

```{r}
#| echo: true
#| code-fold: true

# VERSION 1 - avec int√©gration de la variable globale

z_a1 <- function(u, v, c) {
    return(u[v] * c)
}
```

```{r}
#| echo: true
#| code-fold: true

# VERSION 2 - avec documentation implicite

multiply_vector_element <- function(integer_vector, index, multiplier) {
    multiplied_element <- integer_vector[index] * multiplier
    return(multiplied_element)
}
```

```{r}
#| echo: true
#| code-fold: true

# VERSION 3 - avec documentation compl√®te

#' @title Multiplie un √©l√©ment de vecteur
#' @description Multiplie un √©l√©ment de vecteur choisi par l'utilisateur par un multiplicateur sp√©cifi√©.
#' 
#' @param integer_vector Un vecteur num√©rique
#' @param index L'indice de l'√©l√©ment √† multiplier dans le vecteur
#' @param multiplier Le multiplicateur num√©rique
#' 
#' @returns L'√©l√©ment multipli√©
#' 
#' @examples
#' multiply_vector_element(c(1,2,4), 2, 8)
#' [1] 16
multiply_vector_element <- function(integer_vector, index, multiplier) {
    multiplied_element <- integer_vector[index] * multiplier
    return(multiplied_element)
}
```


## Linter

::: {.callout-tip}

## Le linter, un r√¢leur bienveillant

Permet d'analyser le code √† la recherche d'erreurs et de probl√®mes stylistiques. 

Sur {{< iconify fa6-brands:r-project >}}, le **linter** recommand√© est le package `{lintr}`.

:::

```r
install.packages("lintr")

lintr::use_lintr(type = "tidyverse")
lintr::lint("hello.R")
```

:::{.notes}
On va installer le package, et ensuite on va initialiser une configuration de linter, et on va √©crire un script tout pourri expr√®s pour se prendre plein d'avertissements.
:::

## Styler

::: {.callout-tip}

## Style Matters.

`{styler}` est un package con√ßu pour formater le code {{< iconify fa6-brands:r-project >}} selon un style particulier pour am√©liorer la lisibilit√©.

:::

```r
install.packages("styler")

styler::style_file("hello.R")
```

<hr>


$\Rightarrow$ C'est un outil tr√®s puissant qui fait gagner beaucoup de temps -- **l'utiliser c'est l'adopter**. 

## Logs (1)

::: {.callout-tip}

## Int√©r√™t des logs

L'utilisation des logs est tr√®s b√©n√©fique pour le d√©bogage, la maintenance et la surveillance en production des potentiels probl√®mes d'une application. 

Il existe de nombreuses libraries sur {{< iconify fa6-brands:r-project >}} pour mettre en place une politique de *logs*. Le plus abouti est le package `{logger}`.
:::


```r
install.packages("logger")

logger::log_info("Ceci est une info")
logger::log_warn("Ceci est un avertissement")
logger::log_error("Ceci est une erreur")
logger::log_fatal("Ceci est une erreur tr√®s grave")
```

## Logs (2)

$\Rightarrow$ Par d√©faut, `{logger}` va √©crire les messages dans la console au format suivant :

```bash
INFO [2024-08-12 10:48:56] Ceci est une info
WARN [2024-08-12 10:48:56] Ceci est un avertissement
ERROR [2024-08-12 10:48:56] Ceci est une erreur
FATAL [2024-08-12 10:48:56] Ceci est une erreur tr√®s grave
```

Mais on peut aussi configurer des fichiers de *logs* rotatifs avec `log_appender()`

```r
library(logger)

log_file <- "logs/logfile"

log_appender(appender_file(log_file, max_lines = 10))
```

## Logs (3) {.smaller}

> Faisons une fonction qui va prendre un entr√©e un vecteur num√©rique, par exemple `c(1,8,9,15)` et qui va faire la moyenne de ce vecteur. Plusieurs conditions sont √† v√©rifier, et les logs sont √† mettre en place pour chaque condition.

```{r}
#| echo: true
#| code-fold: true
log_mean_calculation <- function(numbers) {
    if (!is.numeric(numbers)) {
        log_error("Le vecteur numbers : {numbers} contient des √©l√©ments non num√©riques.")
        mean_value <- NA
    } else if (length(numbers) == 0) {
        log_warn("Le vecteur numbers est vide")
        mean_value <- NA
    } else {
        log_info("Fonction appel√©e avec le vecteur de nombres suivants : {numbers}")
        mean_value <- mean(numbers)
        log_success("Le calcul de la moyenne est termin√©. La valeur est : {mean_value}")
    }

    return(mean_value)
}
```

:::{.notes}
Apr√®s c'est vrai que pour une fonction qui calcule une moyenne c'est un peu **OVERKILL** de mettre des logs. Si on fait √ßa partout, on est pas rendus.

Par contre, quand vous √©crivez/importez des fichiers, quand vous faites des op√©rations importantes, les logs sont vraiment utiles. 

Par exemple sur HPConnect quand l'utilisateur g√©n√®re une fiche, en parall√®le les logs sont aussi g√©n√©r√©s pour garder un √©tat de ce qui s'est pass√©. En bref sur une appli Shiny qui est en prod, c'est bien d'avoir des logs.
:::

## Pipes {.smaller}

::: {.callout-tip}

Depuis la version 4.1, R a introduit le *pipe*, un nouvel op√©rateur not√© `|>` -- le raccourci clavier associ√© est **Ctrl+Shift+M**.

Le principe de cet op√©rateur est de passer l‚Äô√©l√©ment situ√© √† sa gauche comme premier argument de la fonction situ√©e √† sa droite. Ainsi, l‚Äô√©criture `x |> f()` est √©quivalente √† `f(x)` et l‚Äô√©criture `x |> f(y)` √† `f(x, y)`.

:::

**Version sans pipe** :

```{r}
#| echo: true

v_num <- c(1.2, 8.9, 55.6, 11.4)

format(round(mean(v_num), digits = 1), decimal.mark = ",")
```

**Version avec pipe** :

```{r}
#| echo: true

v_num |> 
    mean() |> 
    round(digits = 1) |> 
    format(decimal.mark = ",")
```

$\Rightarrow$ Meilleure d√©composition et lisibilit√© du code en cha√Ænant les op√©rations. 

## Git (1)

::: {.callout-tip}

## What the Git ?

**Git** est un syst√®me de contr√¥le de version distribu√©. Il permet de g√©rer facilement l'int√©gration des changements dans le code source, cr√©er des branches, naviguer dans l'historique de code, etc.

:::

::: {.callout-warning}

## Installation de **Git**

Il faut pr√©alablement installer **Git** sur sa machine pour pouvoir commencer

$\Rightarrow$ [https://git-scm.com/download/win](https://git-scm.com/download/win)

:::

## Git (2)

Sur {{< iconify fa6-brands:r-project >}}, le package `{gert}` permet justement de faire des manipulations avec **Git**, tout en restant dans la console {{< iconify fa6-brands:r-project >}}.

```r
install.packages("gert")

gert::git_init()
gert::git_add("mon_fichier.txt")
gert::git_add(".")
gert::git_branch()
gert::git_branch_list()
gert::git_branch_create("nouvelle_branche")
gert::git_status()
gert::git_commit("Ma modification")
gert::git_push()
gert::git_pull()
```

## Interop√©rabilit√© (1) {.smaller}

Sur {{< iconify fa6-brands:r-project >}}, il existe de nombreuses mani√®res de stocker des donn√©es : cr√©er des fichiers *csv*, *xlsx*, *json*, etc. 

Un format se d√©marque en particulier : le `.RData`. Il est tr√®s simple d'utilisation et est compress√© par d√©faut, ce qui le rend attractif... mais c'est un format propri√©taire.

::: {.callout-tip}

## Le format `parquet`

Cr√©e en 2013 par **Cloudera** et {{< iconify fa6-brands:twitter >}} **Twitter** pour r√©pondre √† des probl√©matiques de Big Data.

**Avantages du format** :

1Ô∏è‚É£ Pr√©sence du sch√©ma de donn√©es dans le fichier

2Ô∏è‚É£ Compatibilit√© avec Java, R, Python, C++, Rust, etc.

3Ô∏è‚É£ Compression des donn√©es gr√¢ce √† son format "orient√© colonnes"

:::


:::{.notes}
Probl√®me des RData : c'esgt pour le coup un super format √† partir du moment o√π on reste dans R. Mais par contre si on veut manipuler les donn√©es avec un autre langage l√† c'est pas la m√™me histoire. L'interop√©rabilit√© elle est proche de 0. √ßa c'est pas ouf. 
:::

## Interop√©rabilit√© (2) {.smaller}

```r
install.packages("arrow")
```


$\Rightarrow$ **Mise en pratique** !

## Tidyverse

`{tibble}` et `{purrr}`